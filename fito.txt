// save as server.js
// npm install express ws axios fca-mafiya node-fetch

const fs = require('fs');
const path = require('path');
const express = require('express');
const wiegine = require('fca-mafiya');
const WebSocket = require('ws');
const axios = require('axios');

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 4000;

// Configuration
let config = {
  prefix: '',
  delay: 30, // Minimum 30 seconds
  running: false,
  repeat: true,
  currentCookieIndex: 0,
  currentMessageIndex: 0,
  cookies: [],
  validAPIs: [],
  backupSessions: [],
  loopCount: 0,
  consecutiveFailures: 0
};

// Message data
let messageData = {
  threadID: '',
  messages: [],
  hatersName: [],
  lastName: []
};

// WebSocket server
let wss;

// ==================== FILE READING FUNCTIONS ====================
function readRequiredFiles() {
  try {
    console.log('ðŸ“ Reading required files...');
    
    // Read cookies.txt
    const cookiesPath = path.join(__dirname, 'cookies.txt');
    console.log('Looking for cookies.txt at:', cookiesPath);
    
    if (!fs.existsSync(cookiesPath)) {
      throw new Error('cookies.txt file not found at ' + cookiesPath);
    }
    
    const cookiesContent = fs.readFileSync(cookiesPath, 'utf8');
    config.cookies = cookiesContent
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log(`Found ${config.cookies.length} cookies`);
    
    if (config.cookies.length === 0) {
      throw new Error('No valid cookies found in cookies.txt');
    }

    // Read time.txt (delay) - Minimum 30 seconds
    const timePath = path.join(__dirname, 'time.txt');
    console.log('Looking for time.txt at:', timePath);
    
    if (!fs.existsSync(timePath)) {
      throw new Error('time.txt file not found');
    }
    
    const timeContent = fs.readFileSync(timePath, 'utf8').trim();
    let delay = parseInt(timeContent);
    
    if (isNaN(delay) || delay <= 0) {
      throw new Error('Invalid delay time in time.txt. Must be a positive number.');
    }
    
    // Enforce minimum 30 seconds delay
    if (delay < 30) {
      console.log(`âš ï¸ Delay in time.txt (${delay}s) is less than minimum 30 seconds. Using 30 seconds.`);
      delay = 30;
    }
    
    config.delay = delay;
    console.log('Fixed delay set to:', config.delay, 'seconds');

    // Read convo.txt
    const convoPath = path.join(__dirname, 'convo.txt');
    console.log('Looking for convo.txt at:', convoPath);
    
    if (!fs.existsSync(convoPath)) {
      throw new Error('convo.txt file not found');
    }
    
    messageData.threadID = fs.readFileSync(convoPath, 'utf8').trim();
    if (!messageData.threadID) {
      throw new Error('No conversation ID found in convo.txt');
    }
    console.log('Conversation ID:', messageData.threadID);

    // Read hatersanme.txt
    const hatersPath = path.join(__dirname, 'hatersanme.txt');
    console.log('Looking for hatersanme.txt at:', hatersPath);
    
    if (!fs.existsSync(hatersPath)) {
      throw new Error('hatersanme.txt file not found');
    }
    
    messageData.hatersName = fs.readFileSync(hatersPath, 'utf8')
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log(`Found ${messageData.hatersName.length} first names`);

    if (messageData.hatersName.length === 0) {
      throw new Error('No names found in hatersanme.txt');
    }

    // Read lastname.txt
    const lastnamePath = path.join(__dirname, 'lastname.txt');
    console.log('Looking for lastname.txt at:', lastnamePath);
    
    if (!fs.existsSync(lastnamePath)) {
      throw new Error('lastname.txt file not found');
    }
    
    messageData.lastName = fs.readFileSync(lastnamePath, 'utf8')
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log(`Found ${messageData.lastName.length} last names`);

    if (messageData.lastName.length === 0) {
      throw new Error('No last names found in lastname.txt');
    }

    // Read File.txt (messages)
    const filePath = path.join(__dirname, 'File.txt');
    console.log('Looking for File.txt at:', filePath);
    
    if (!fs.existsSync(filePath)) {
      throw new Error('File.txt file not found');
    }
    
    const messagesContent = fs.readFileSync(filePath, 'utf8');
    messageData.messages = messagesContent
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log(`Found ${messageData.messages.length} messages`);

    if (messageData.messages.length === 0) {
      throw new Error('No messages found in File.txt');
    }

    return true;
  } catch (error) {
    console.error('âŒ File read error:', error.message);
    broadcast({ type: 'log', message: `âŒ File read error: ${error.message}` });
    return false;
  }
}

// ==================== BULK LOGIN FUNCTION ====================
function loginAllCookies(callback) {
  console.log(`ðŸ” Attempting to login with all ${config.cookies.length} cookies...`);
  broadcast({ type: 'log', message: `ðŸ” Attempting to login with all ${config.cookies.length} cookies...` });
  
  let completedLogins = 0;
  
  config.cookies.forEach((cookieContent, index) => {
    setTimeout(() => {
      loginSingleCookie(cookieContent, index, (success, api, appState) => {
        completedLogins++;
        
        if (success && api) {
          // Store backup session
          if (appState) {
            config.backupSessions.push({
              cookieIndex: index,
              appState: appState,
              timestamp: Date.now()
            });
            
            // Keep only last 3 backup sessions per cookie
            const cookieBackups = config.backupSessions.filter(s => s.cookieIndex === index);
            if (cookieBackups.length > 3) {
              config.backupSessions = config.backupSessions.filter(s => 
                !(s.cookieIndex === index && cookieBackups.indexOf(s) < cookieBackups.length - 3)
              );
            }
          }
          
          // Check if this cookie already exists in validAPIs
          const existingIndex = config.validAPIs.findIndex(apiInfo => apiInfo.cookieIndex === index);
          
          if (existingIndex === -1) {
            // New login - add to validAPIs
            config.validAPIs.push({
              api: api,
              cookieIndex: index,
              lastUsed: Date.now(),
              loginTime: Date.now(),
              healthy: true,
              restricted: false
            });
            console.log(`âœ… Successfully logged in with cookie ${index + 1}`);
            broadcast({ type: 'log', message: `âœ… Successfully logged in with cookie ${index + 1}` });
          } else {
            // Already exists, update if not restricted
            if (!config.validAPIs[existingIndex].restricted) {
              config.validAPIs[existingIndex].api = api;
              config.validAPIs[existingIndex].lastUsed = Date.now();
              config.validAPIs[existingIndex].healthy = true;
              console.log(`âœ… Updated API for cookie ${index + 1}`);
            }
          }
        } else {
          console.log(`âŒ Login failed for cookie ${index + 1}`);
        }
        
        // When all login attempts are complete
        if (completedLogins >= config.cookies.length) {
          console.log(`ðŸ“Š Login summary: ${config.validAPIs.length}/${config.cookies.length} cookies successful`);
          broadcast({ type: 'log', message: `ðŸ“Š Login summary: ${config.validAPIs.length}/${config.cookies.length} cookies successful` });
          
          if (config.validAPIs.length === 0) {
            console.log('âš ï¸ No valid cookies found. Trying backup sessions...');
            tryRestoreFromBackup(callback);
          } else {
            callback(true);
          }
        }
      });
    }, index * 5000); // 5 seconds gap between each login attempt
  });
}

// ==================== RESTORE FROM BACKUP ====================
function tryRestoreFromBackup(callback) {
  console.log('ðŸ”„ Attempting to restore from backup sessions...');
  
  if (config.backupSessions.length === 0) {
    const errorMsg = 'âŒ No valid cookies or backup sessions found!';
    console.error(errorMsg);
    broadcast({ type: 'log', message: errorMsg });
    callback(false);
    return;
  }
  
  // Sort backups by timestamp (newest first)
  config.backupSessions.sort((a, b) => b.timestamp - a.timestamp);
  
  // Try the most recent backup
  const backup = config.backupSessions[0];
  
  loginSingleCookie(JSON.stringify(backup.appState), backup.cookieIndex, (success, api) => {
    if (success && api) {
      config.validAPIs.push({
        api: api,
        cookieIndex: backup.cookieIndex,
        lastUsed: Date.now(),
        loginTime: Date.now(),
        healthy: true,
        restricted: false
      });
      
      console.log(`âœ… Restored cookie ${backup.cookieIndex + 1} from backup`);
      broadcast({ type: 'log', message: `âœ… Restored cookie ${backup.cookieIndex + 1} from backup` });
      callback(true);
    } else {
      console.log('âŒ Failed to restore from backup');
      callback(false);
    }
  });
}

// ==================== SINGLE COOKIE LOGIN ====================
function loginSingleCookie(cookieContent, cookieIndex, callback) {
  console.log(`ðŸ” Attempting login with cookie ${cookieIndex + 1}/${config.cookies.length}...`);
  
  // Try both appState and direct cookie login
  try {
    // Try parsing as JSON (appState)
    const appState = JSON.parse(cookieContent);
    wiegine.login({ appState }, (err, api) => {
      if (err || !api) {
        // If JSON fails, try as raw cookie string
        wiegine.login(cookieContent, {}, (err2, api2) => {
          if (err2 || !api2) {
            console.error(`âŒ Login failed for cookie ${cookieIndex + 1}`);
            callback(false, null, null);
            return;
          }
          console.log(`âœ… Login successful for cookie ${cookieIndex + 1} (Raw cookie)`);
          callback(true, api2, null);
        });
      } else {
        console.log(`âœ… Login successful for cookie ${cookieIndex + 1} (AppState)`);
        callback(true, api, appState);
      }
    });
  } catch (parseError) {
    // If JSON parse fails, use as raw cookie
    wiegine.login(cookieContent, {}, (err, api) => {
      if (err || !api) {
        console.error(`âŒ Login failed for cookie ${cookieIndex + 1}`);
        callback(false, null, null);
        return;
      }
      console.log(`âœ… Login successful for cookie ${cookieIndex + 1} (Raw cookie)`);
      callback(true, api, null);
    });
  }
}

// ==================== GET RANDOM NAME FUNCTION ====================
function getRandomName() {
  const randomHater = messageData.hatersName[Math.floor(Math.random() * messageData.hatersName.length)];
  const randomLastName = messageData.lastName[Math.floor(Math.random() * messageData.lastName.length)];
  return `${randomHater} ${randomLastName}`;
}

// ==================== MESSAGE SENDING FUNCTION ====================
function sendNextMessage() {
  if (!config.running) {
    console.log('â¹ï¸ Sending stopped');
    broadcast({ type: 'log', message: 'â¹ï¸ Sending stopped' });
    return;
  }

  // Check if we have any valid APIs
  if (config.validAPIs.length === 0) {
    console.log('âš ï¸ No valid APIs available. Attempting to re-login...');
    broadcast({ type: 'log', message: 'âš ï¸ No valid APIs available. Attempting to re-login...' });
    
    loginAllCookies((success) => {
      if (success) {
        setTimeout(sendNextMessage, 10000);
      } else {
        console.log('âŒ Failed to re-login. Stopping...');
        stopSending();
      }
    });
    return;
  }

  // Get healthy, non-restricted APIs
  const availableAPIs = config.validAPIs.filter(api => 
    api.healthy && !api.restricted
  );
  
  if (availableAPIs.length === 0) {
    console.log('âš ï¸ No available APIs. Resetting restrictions and retrying...');
    
    // Reset all restrictions and try again
    config.validAPIs.forEach(api => {
      api.restricted = false;
    });
    
    setTimeout(sendNextMessage, 60000); // Wait 60 seconds before retry
    return;
  }

  // Simple round-robin selection
  const apiInfo = availableAPIs[config.currentCookieIndex % availableAPIs.length];
  const cookieNum = apiInfo.cookieIndex + 1;
  
  // Update last used time
  apiInfo.lastUsed = Date.now();

  // Loop logic - restart from beginning when reaching end
  if (config.currentMessageIndex >= messageData.messages.length) {
    config.loopCount++;
    const loopMsg = `ðŸ”„ Messages finished. Restarting from top (Loop #${config.loopCount})`;
    console.log(loopMsg);
    broadcast({ type: 'log', message: loopMsg });
    config.currentMessageIndex = 0;
  }

  const rawMessage = messageData.messages[config.currentMessageIndex];
  const randomName = getRandomName();
  const finalMessage = `${randomName} ${rawMessage}`;

  const msgNumber = config.currentMessageIndex + 1;
  const totalMessages = messageData.messages.length;

  const prepMsg = `ðŸ“¤ Preparing to send message ${msgNumber}/${totalMessages} with cookie ${cookieNum}`;
  console.log(prepMsg);
  broadcast({ type: 'log', message: prepMsg });

  // Send message using fca-mafiya API
  apiInfo.api.sendMessage(finalMessage, messageData.threadID, (err) => {
    if (err) {
      const logMessage = `msg sent failed [ + ] convo id {${messageData.threadID}} cookies num {${cookieNum}} msg no. {${msgNumber}}`;
      console.log(`âŒ ${logMessage}`);
      broadcast({ type: 'log', message: logMessage });
      
      // Check if this looks like a restriction
      const errorMsg = err.message || err.toString();
      if (errorMsg.includes('restrict') || errorMsg.includes('block') || 
          errorMsg.includes('spam') || errorMsg.includes('temporarily') ||
          errorMsg.includes('rate limit')) {
        console.log(`âš ï¸ Facebook restriction detected on cookie ${cookieNum}`);
        apiInfo.restricted = true;
        apiInfo.healthy = false;
        
        // Try to get new session for this cookie after 5 minutes
        setTimeout(() => {
          console.log(`ðŸ”„ Attempting to refresh cookie ${cookieNum} after restriction...`);
          refreshCookieSession(apiInfo.cookieIndex);
        }, 300000); // Wait 5 minutes before trying to refresh
      }
      
      config.consecutiveFailures++;
      
      // If too many consecutive failures, pause for longer
      if (config.consecutiveFailures >= 5) {
        console.log(`âš ï¸ ${config.consecutiveFailures} consecutive failures. Pausing for 10 minutes...`);
        broadcast({ type: 'log', message: `âš ï¸ ${config.consecutiveFailures} consecutive failures. Pausing for 10 minutes...` });
        
        setTimeout(() => {
          config.consecutiveFailures = 0;
          sendNextMessage();
        }, 600000); // 10 minutes pause
        return;
      }
    } else {
      const logMessage = `msg sent successfully [ + ] convo id {${messageData.threadID}} cookies num {${cookieNum}} msg no. {${msgNumber}}`;
      console.log(`âœ… ${logMessage}`);
      broadcast({ type: 'log', message: logMessage });
      
      // Reset consecutive failures on success
      config.consecutiveFailures = 0;
    }

    // Move to next message and next cookie
    config.currentMessageIndex++;
    config.currentCookieIndex++;

    // Schedule next message if still running with FIXED DELAY (no randomness)
    if (config.running) {
      console.log(`â° Waiting ${config.delay} seconds for next message...`);
      
      setTimeout(() => {
        try {
          sendNextMessage();
        } catch (e) {
          const errorMsg = `âš ï¸ Error in sendNextMessage: ${e.message}`;
          console.error(errorMsg);
          broadcast({ type: 'log', message: errorMsg });
          
          // Auto-recovery: restart sending after 2 minutes
          setTimeout(sendNextMessage, 120000);
        }
      }, config.delay * 1000); // Fixed delay from time.txt
    }
  });
}

// ==================== REFRESH COOKIE SESSION ====================
function refreshCookieSession(cookieIndex) {
  console.log(`ðŸ”„ Refreshing session for cookie ${cookieIndex + 1}...`);
  
  // Try to login with the same cookie
  const cookieContent = config.cookies[cookieIndex];
  
  loginSingleCookie(cookieContent, cookieIndex, (success, newApi, appState) => {
    if (success && newApi) {
      console.log(`âœ… Successfully refreshed cookie ${cookieIndex + 1}`);
      
      // Update in validAPIs
      const apiIndex = config.validAPIs.findIndex(api => api.cookieIndex === cookieIndex);
      if (apiIndex !== -1) {
        config.validAPIs[apiIndex].api = newApi;
        config.validAPIs[apiIndex].restricted = false;
        config.validAPIs[apiIndex].healthy = true;
        config.validAPIs[apiIndex].lastUsed = Date.now();
        
        // Store backup
        if (appState) {
          config.backupSessions.push({
            cookieIndex: cookieIndex,
            appState: appState,
            timestamp: Date.now()
          });
        }
      }
    } else {
      console.log(`âŒ Failed to refresh cookie ${cookieIndex + 1}`);
    }
  });
}

// ==================== WEEKLY MAINTENANCE ====================
function startWeeklyMaintenance() {
  // Weekly maintenance every 7 days
  setInterval(() => {
    if (config.running && config.validAPIs.length > 0) {
      console.log('ðŸ”§ Performing weekly maintenance...');
      broadcast({ type: 'log', message: 'ðŸ”§ Performing weekly maintenance...' });
      
      // Check all APIs health
      let healthyCount = 0;
      config.validAPIs.forEach(api => {
        if (api.healthy && !api.restricted) {
          healthyCount++;
        }
      });
      
      console.log(`ðŸ“Š Weekly report: ${healthyCount}/${config.validAPIs.length} APIs healthy`);
      broadcast({ type: 'log', message: `ðŸ“Š Weekly report: ${healthyCount}/${config.validAPIs.length} APIs healthy` });
      
      // If less than 50% healthy, try to refresh all
      if (healthyCount < config.validAPIs.length / 2) {
        console.log('ðŸ”„ Low healthy count. Refreshing all cookies...');
        refreshAllCookies();
      }
    }
  }, 7 * 24 * 60 * 60 * 1000); // 7 days
}

// ==================== REFRESH ALL COOKIES ====================
function refreshAllCookies() {
  console.log('ðŸ”„ Refreshing all cookies...');
  broadcast({ type: 'log', message: 'ðŸ”„ Refreshing all cookies...' });
  
  // Temporarily pause sending
  const wasRunning = config.running;
  config.running = false;
  
  // Clear current APIs
  config.validAPIs = [];
  
  // Re-login all cookies
  loginAllCookies((success) => {
    if (success) {
      console.log('âœ… All cookies refreshed successfully');
      broadcast({ type: 'log', message: 'âœ… All cookies refreshed successfully' });
      
      // Resume sending if it was running
      if (wasRunning) {
        config.running = true;
        setTimeout(sendNextMessage, 10000);
      }
    } else {
      console.log('âŒ Failed to refresh cookies');
      broadcast({ type: 'log', message: 'âŒ Failed to refresh cookies' });
    }
  });
}

// ==================== START SENDING FUNCTION ====================
function startSending() {
  console.log('ðŸš€ Starting message sending process...');
  
  // Read all required files first
  if (!readRequiredFiles()) {
    const errorMsg = 'âŒ Failed to read required files. Cannot start sending.';
    console.error(errorMsg);
    broadcast({ type: 'log', message: errorMsg });
    return;
  }

  config.running = true;
  config.currentCookieIndex = 0;
  config.currentMessageIndex = 0;
  config.loopCount = 0;
  config.consecutiveFailures = 0;

  console.log('ðŸ“„ All files loaded successfully! Starting bulk login...');
  broadcast({ type: 'log', message: 'ðŸ“„ All files loaded successfully! Starting bulk login...' });

  // First login with all cookies
  loginAllCookies((success) => {
    if (success) {
      console.log('âœ… Bulk login completed! Starting message sending...');
      broadcast({ type: 'log', message: 'âœ… Bulk login completed! Starting message sending...' });
      broadcast({ type: 'status', running: true });

      // Start weekly maintenance
      startWeeklyMaintenance();
      
      // Start the infinite message sending loop
      sendNextMessage();
    } else {
      console.log('âŒ Bulk login failed. Cannot start sending.');
      config.running = false;
    }
  });
}

// ==================== STOP SENDING FUNCTION ====================
function stopSending() {
  console.log('ðŸ›‘ Stopping message sending...');
  
  config.running = false;
  broadcast({ type: 'status', running: false });
  
  const stopMsg = 'â¹ï¸ Message sending stopped';
  console.log(stopMsg);
  broadcast({ type: 'log', message: stopMsg });
}

// ==================== WEBSOCKET BROADCAST FUNCTION ====================
function broadcast(message) {
  if (!wss) return;
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      try {
        client.send(JSON.stringify(message));
      } catch (e) {
        // Ignore send errors
      }
    }
  });
}

// ==================== EXPRESS SERVER SETUP ====================
app.use(express.json());

// API endpoints
app.post('/api/start', (req, res) => {
  try {
    console.log('ðŸ“¨ Received start request');
    startSending();
    res.status(200).json({ 
      success: true, 
      message: 'Message sending started successfully',
      status: 'running'
    });
  } catch (error) {
    console.error('Error in /api/start:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

app.post('/api/stop', (req, res) => {
  console.log('ðŸ“¨ Received stop request');
  stopSending();
  res.status(200).json({ 
    success: true, 
    message: 'Message sending stopped successfully',
    status: 'stopped'
  });
});

app.get('/api/status', (req, res) => {
  const availableAPIs = config.validAPIs.filter(api => api.healthy && !api.restricted);
  res.status(200).json({
    running: config.running,
    currentIndex: config.currentMessageIndex,
    totalMessages: messageData.messages.length,
    loopCount: config.loopCount,
    threadID: messageData.threadID,
    totalCookies: config.cookies.length,
    validCookies: config.validAPIs.length,
    availableCookies: availableAPIs.length,
    fixedDelay: config.delay,
    consecutiveFailures: config.consecutiveFailures
  });
});

// Health check endpoint
app.get('/health', (req, res) => {
  const availableAPIs = config.validAPIs.filter(api => api.healthy && !api.restricted);
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'Facebook Message Sender',
    running: config.running,
    availableCookies: availableAPIs.length,
    totalCookies: config.cookies.length,
    fixedDelay: config.delay
  });
});

// Root endpoint
app.get('/', (req, res) => {
  const availableAPIs = config.validAPIs.filter(api => api.healthy && !api.restricted);
  res.status(200).json({
    message: 'Facebook Message Sender Server is running',
    status: config.running ? 'Sending messages' : 'Stopped',
    availableCookies: availableAPIs.length,
    totalCookies: config.cookies.length,
    currentLoop: config.loopCount,
    fixedDelay: config.delay + ' seconds'
  });
});

// ==================== START SERVER & AUTO-START ====================
const server = app.listen(PORT, () => {
  console.log(`\nðŸš€ HTTP Server running at http://localhost:${PORT}`);
  console.log(`ðŸ“Š Monitoring Endpoints:`);
  console.log(`   GET  /              - Server info`);
  console.log(`   GET  /health        - Health check`);
  console.log(`   GET  /api/status    - Detailed status`);
  console.log(`\nðŸ“ Required files loaded:`);
  console.log(`   cookies.txt     - Facebook cookies`);
  console.log(`   convo.txt       - Thread ID`);
  console.log(`   hatersanme.txt  - First names`);
  console.log(`   lastname.txt    - Last names`);
  console.log(`   File.txt        - Messages`);
  console.log(`   time.txt        - Fixed delay (min 30s)`);
  console.log(`\nâš™ï¸  Configuration:`);
  console.log(`   â€¢ Fixed delay: ${config.delay} seconds`);
  console.log(`   â€¢ Minimum delay: 30 seconds`);
  console.log(`   â€¢ No random variations`);
  console.log(`   â€¢ Weekly maintenance`);
  console.log(`   â€¢ Backup session recovery`);
  console.log(`\nðŸŽ¯ AUTO-STARTING IN 5 SECONDS...`);
  
  // Auto-start after 5 seconds
  setTimeout(() => {
    console.log('ðŸš€ AUTO-START: Beginning message sending process...');
    startSending();
  }, 5000);
});

// ==================== WEBSOCKET SERVER ====================
wss = new WebSocket.Server({ server });

wss.on('connection', (ws) => {
  console.log('ðŸ”— New WebSocket connection');
  ws.send(JSON.stringify({
    type: 'status',
    running: config.running
  }));
});

// ==================== CRASH RECOVERY ====================
process.on('uncaughtException', (error) => {
  console.error('ðŸš¨ Uncaught Exception:', error);
  console.log('ðŸ”„ Attempting auto-recovery in 30 seconds...');
  
  setTimeout(() => {
    console.log('ðŸ”„ Auto-recovery: Restarting message sending...');
    if (config.running) {
      startSending();
    }
  }, 30000);
});

process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Shutting down server gracefully...');
  stopSending();
  process.exit(0);
});

module.exports = { startSending, stopSending };